<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Catyee&#39;s Tech Blog</title>
  <subtitle>学习与成长</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-23T01:06:39.225Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Catyee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java设计模式-策略模式</title>
    <link href="http://yoursite.com/2017/05/23/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/05/23/java设计模式-策略模式/</id>
    <published>2017-05-23T00:59:26.000Z</published>
    <updated>2017-05-23T01:06:39.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计原则："><a href="#设计原则：" class="headerlink" title="设计原则："></a><strong>设计原则：</strong></h1><ul>
<li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。把会变化的部分取出并封装起来，好让其他部分不会受到影响。</li>
<li>针对接口编程，而不是针对实现编程。“针对接口编程”的真正意思是针对超类编程。即：变量的申明类应该是超类型，通常是一个抽象类或者一个接口，如此，只要是具体实现此超类的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型。</li>
<li>多用组合，少用继承</li>
</ul>
<h1 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例：</strong></h1><p>世界上有各种鸭子，它们外观不同，但是都会游泳，也都会叫。用传统的面向对象的思路来设计，首先有一个Duck的抽象超类，并让各种鸭子继承这个超类。<br>| Duck |<br>|:——|<br>|quack()//鸭子叫的方法|<br>|swim()//鸭子游泳的方法|<br>|display()//鸭子外观的方法|<br>如果是传统的面向对象思想，所有的鸭子都会叫，也都会游泳，所以quack()方法和swim()方法放在超类Duck中实现，而由于每只鸭子的外观不同，所以display()方法在Duck类中设计成抽象方法，由具体的鸭子继承超类后自己去实现。比如现在有绿头鸭MallardDuck和红头鸭ReaheadDuck，它们继承超类Duck，所以有了quack和swim的功能，同时实现display方法从而有了不同的外观。</p>
<p>但是这样设计有一个问题：<br>需求开始增加，经过分析，发现鸭子都会飞，所以要给鸭子加上飞的功能。最普通的方法是在Duck超类中加一个fly()的方法并实现。这样每一个鸭子继承Duck之后就有了fly()的功能。但是发现需求有误，实际上并不是所有鸭子都会飞。比如尖叫鸭（类似于尖叫鸡），会叫也会游泳，但是尖叫鸭的叫声是“吱吱”，而不是普通鸭子的“咕咕”。所以尖叫鸭继承Duck之后首先要覆盖掉超类中的quack()方法。最严重的问题是尖叫鸭不会飞，但是继承Duck后它有了飞的功能，这肯定不对。同样的方法就是子类继承超类之后覆盖掉Duck中的fly()方法。但是，如果以后还要加入另一种诱饵鸭子，它其实是一个木头假鸭，不会叫也不会飞。难道又要覆盖掉quack()方法和fly()方法吗？这样太不优雅了。可以看到用继承的方式来提供Duck的行为，会使代码牵一发动全身，不便于维护，也不便于扩展。</p>
<p>所以需要一个更清晰的方法，让“某些”而不是全部鸭子可飞或者可叫。<br>很自然的一种想法是把飞好叫的行为从Duck超类拿出来，另外设计成接口：Flyable和Quackable。<br>| Duck//抽象类 | | Flyable//接口|  | Quackable//接口|<br>|——| |——–|  |——–|<br>|swim()//普通方法| | fly()//接口中的抽象方法| | quack()//接口中的抽象方法|<br>|display()//抽象方法|<br>这样尖叫鸭可以继承Duck超类，同时实现Quackable接口，而普通鸭子可以继承Duck超类并同时实现Flyable和Quack接口，但是可以看到，每实现一次接口就要重写一此接口中的方法，重复的代码就会急剧增加。显然这不是一种好的方法。</p>
<p>可以看出造成目前这种困境的原因是需求一直在改变。而现实中需求的改变又恰恰是经常会出现的问题。这个时候就要<strong>找出应用中可能需要经常变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起。也就是把会变化的部分取出并封装起来，好让其他部分不会受到影响。</strong><br>那么具体到这个例子中要怎么做呢？首先在原始的Duck类中把fly()和quack()拿掉，然后建立两组类，一类与fly相关，一类与quack相关，它们分别实现FlyBehavior和QuackBehavior接口。每一组类将实现各自的动作，可能有一个类实现Quackbehhavior接口完成了“咕咕叫”(Quack类)，另一个类实现Quackbehhavior接口完成了“吱吱叫”(SQuack类)，还有一个类实现Quackbehhavior接口完成了“安静”(MuteQuack类)。另外还有一个类实现FlyBehavior接口完成了“飞”的功能（FlyWithSwing类），还有一个类实现FlyBehavior接口完成了“不能飞”（FlyNoWay类）。<br>但仅仅是这样还不够，因为Java中并没有多继承，如果继承了Duck超类，就不能继承那些实现了FlyBehavior或QuackBehavior的具体实现类。所以要想一种办法把Duck类和我们分离出来的行为整合起来。其实就是在Duck类中添加FlyBehavior和QuackBehavior的属性：<br>| Duck |<br>|:——|<br>|FlyBehavior flyBehavior//飞属性|<br>|QuackBehavior quackBehavior//叫属性|<br>|swim()//鸭子游泳的方法|<br>|display()//鸭子外观的方法|<br>|performFly()//飞行方法|<br>|performQuack()//叫方法|</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">    FlyBehavior flyBehavior;</div><div class="line">    QuackBehavior quackBehavior;</div><div class="line">    </div><div class="line">    //set、get方法</div><div class="line">    ...</div><div class="line">    public abstract void display();</div><div class="line">    public void swim()&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    public void performFly()&#123;</div><div class="line">        flyBehavior.fly();</div><div class="line">    &#125;</div><div class="line">    public void performQuack()&#123;</div><div class="line">        quackBehavior.quack();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样当我们实现尖叫鸭的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ScreamDuck extends Duck&#123;</div><div class="line">    public ScreamDuck()&#123;</div><div class="line">        quackBehavior = new SQuack();</div><div class="line">        flyBehavior = new FlyNoWay();</div><div class="line">    &#125;</div><div class="line">    @override</div><div class="line">    public void display()&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就实现了一个尖叫鸭。而普通绿头鸭子就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MallardDuck extends Duck&#123;</div><div class="line">    public MallardDuck()&#123;</div><div class="line">        quackBehavior = new Quack();</div><div class="line">        flyBehavior = new FlyWithSwing();</div><div class="line">    &#125;</div><div class="line">    @override</div><div class="line">    public void display()&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样维护和扩展都容易多了。</p>
<p>这就是<strong>策略模式</strong>，<br>**</p>
<h1 id="策略模式的定义："><a href="#策略模式的定义：" class="headerlink" title="策略模式的定义："></a><strong>策略模式的定义：</strong></h1><p>**<br>定义了算法簇，分别封装起来，让它们之间可以互相替换。这个模式可以让算法的变化独立于使用算法的客户。</p>
<h1 id="策略模式的结构："><a href="#策略模式的结构：" class="headerlink" title="策略模式的结构："></a><strong>策略模式的结构：</strong></h1><p><img src="http://my.csdn.net/uploads/201205/11/1336732187_4598.jpg" alt="策略模式的结构"></p>
<p>**</p>
<h1 id="策略模式的组成："><a href="#策略模式的组成：" class="headerlink" title="策略模式的组成："></a><strong>策略模式的组成：</strong></h1><p><strong>环境类(Context)</strong>:用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。<br><strong>抽象策略类(Strategy)</strong>:定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。<br><strong>具体策略类(ConcreteStrategy)</strong>:以Strategy接口实现某具体算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计原则：&quot;&gt;&lt;a href=&quot;#设计原则：&quot; class=&quot;headerlink&quot; title=&quot;设计原则：&quot;&gt;&lt;/a&gt;&lt;strong&gt;设计原则：&lt;/strong&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/05/22/java%20Strategy/"/>
    <id>http://yoursite.com/2017/05/22/java Strategy/</id>
    <published>2017-05-22T15:43:59.187Z</published>
    <updated>2017-05-22T15:40:04.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Head-First设计模式学习笔记"><a href="#Head-First设计模式学习笔记" class="headerlink" title="Head First设计模式学习笔记"></a>Head First设计模式学习笔记</h1><p>标签（空格分隔）： java 设计模式 策略模式</p>
<hr>
<h1 id="设计原则："><a href="#设计原则：" class="headerlink" title="设计原则："></a><strong>设计原则：</strong></h1><ul>
<li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。把会变化的部分取出并封装起来，好让其他部分不会受到影响。</li>
<li>针对接口编程，而不是针对实现编程。“针对接口编程”的真正意思是针对超类编程。即：变量的申明类应该是超类型，通常是一个抽象类或者一个接口，如此，只要是具体实现此超类的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型。</li>
<li>多用组合，少用继承</li>
</ul>
<h1 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例：</strong></h1><p>世界上有各种鸭子，它们外观不同，但是都会游泳，也都会叫。用传统的面向对象的思路来设计，首先有一个Duck的抽象超类，并让各种鸭子继承这个超类。<br>| Duck |<br>|——|<br>|quack()//鸭子叫的方法|<br>|swim()//鸭子游泳的方法|<br>|display()//鸭子外观的方法|<br>如果是传统的面向对象思想，所有的鸭子都会叫，也都会游泳，所以quack()方法和swim()方法放在超类Duck中实现，而由于每只鸭子的外观不同，所以display()方法在Duck类中设计成抽象方法，由具体的鸭子继承超类后自己去实现。比如现在有绿头鸭MallardDuck和红头鸭ReaheadDuck，它们继承超类Duck，所以有了quack和swim的功能，同时实现display方法从而有了不同的外观。</p>
<p>但是这样设计有一个问题：<br>需求开始增加，经过分析，发现鸭子都会飞，所以要给鸭子加上飞的功能。最普通的方法是在Duck超类中加一个fly()的方法并实现。这样每一个鸭子继承Duck之后就有了fly()的功能。但是发现需求有误，实际上并不是所有鸭子都会飞。比如尖叫鸭（类似于尖叫鸡），会叫也会游泳，但是尖叫鸭的叫声是“吱吱”，而不是普通鸭子的“咕咕”。所以尖叫鸭继承Duck之后首先要覆盖掉超类中的quack()方法。最严重的问题是尖叫鸭不会飞，但是继承Duck后它有了飞的功能，这肯定不对。同样的方法就是子类继承超类之后覆盖掉Duck中的fly()方法。但是，如果以后还要加入另一种诱饵鸭子，它其实是一个木头假鸭，不会叫也不会飞。难道又要覆盖掉quack()方法和fly()方法吗？这样太不优雅了。可以看到用继承的方式来提供Duck的行为，会使代码牵一发动全身，不便于维护，也不便于扩展。</p>
<p>所以需要一个更清晰的方法，让“某些”而不是全部鸭子可飞或者可叫。<br>很自然的一种想法是把飞好叫的行为从Duck超类拿出来，另外设计成接口：Flyable和Quackable。<br>| Duck//抽象类 | | Flyable//接口|  | Quackable//接口|<br>|——| |——–|  |——–|<br>|swim()//普通方法| | fly()//接口中的抽象方法| | quack()//接口中的抽象方法|<br>|display()//抽象方法|<br>这样尖叫鸭可以继承Duck超类，同时实现Quackable接口，而普通鸭子可以继承Duck超类并同时实现Flyable和Quack接口，但是可以看到，每实现一次接口就要重写一此接口中的方法，重复的代码就会急剧增加。显然这不是一种好的方法。</p>
<p>可以看出造成目前这种困境的原因是需求一直在改变。而现实中需求的改变又恰恰是经常会出现的问题。这个时候就要<strong>找出应用中可能需要经常变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起。也就是把会变化的部分取出并封装起来，好让其他部分不会受到影响。</strong><br>那么具体到这个例子中要怎么做呢？首先在原始的Duck类中把fly()和quack()拿掉，然后建立两组类，一类与fly相关，一类与quack相关，它们分别实现FlyBehavior和QuackBehavior接口。每一组类将实现各自的动作，可能有一个类实现Quackbehhavior接口完成了“咕咕叫”(Quack类)，另一个类实现Quackbehhavior接口完成了“吱吱叫”(SQuack类)，还有一个类实现Quackbehhavior接口完成了“安静”(MuteQuack类)。另外还有一个类实现FlyBehavior接口完成了“飞”的功能（FlyWithSwing类），还有一个类实现FlyBehavior接口完成了“不能飞”（FlyNoWay类）。<br>但仅仅是这样还不够，因为Java中并没有多继承，如果继承了Duck超类，就不能继承那些实现了FlyBehavior或QuackBehavior的具体实现类。所以要想一种办法把Duck类和我们分离出来的行为整合起来。其实就是在Duck类中添加FlyBehavior和QuackBehavior的属性：<br>| Duck |<br>|——|<br>|FlyBehavior flyBehavior//飞属性|<br>|QuackBehavior quackBehavior//叫属性|<br>|swim()//鸭子游泳的方法|<br>|display()//鸭子外观的方法|<br>|performFly()//飞行方法|<br>|performQuack()//叫方法|</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">    FlyBehavior flyBehavior;</div><div class="line">    QuackBehavior quackBehavior;</div><div class="line">    </div><div class="line">    //set、get方法</div><div class="line">    ...</div><div class="line">    public abstract void display();</div><div class="line">    public void swim()&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    public void performFly()&#123;</div><div class="line">        flyBehavior.fly();</div><div class="line">    &#125;</div><div class="line">    public void performQuack()&#123;</div><div class="line">        quackBehavior.quack();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样当我们实现尖叫鸭的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ScreamDuck extends Duck&#123;</div><div class="line">    public ScreamDuck()&#123;</div><div class="line">        quackBehavior = new SQuack();</div><div class="line">        flyBehavior = new FlyNoWay();</div><div class="line">    &#125;</div><div class="line">    @override</div><div class="line">    public void display()&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就实现了一个尖叫鸭。而普通绿头鸭子就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MallardDuck extends Duck&#123;</div><div class="line">    public MallardDuck()&#123;</div><div class="line">        quackBehavior = new Quack();</div><div class="line">        flyBehavior = new FlyWithSwing();</div><div class="line">    &#125;</div><div class="line">    @override</div><div class="line">    public void display()&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样维护和扩展都容易多了。</p>
<p>这就是<strong>策略模式</strong>，<br>**</p>
<h1 id="策略模式的定义："><a href="#策略模式的定义：" class="headerlink" title="策略模式的定义："></a><strong>策略模式的定义：</strong></h1><p>**<br>定义了算法簇，分别封装起来，让它们之间可以互相替换。这个模式可以让算法的变化独立于使用算法的客户。</p>
<h1 id="策略模式的结构："><a href="#策略模式的结构：" class="headerlink" title="策略模式的结构："></a><strong>策略模式的结构：</strong></h1><p><img src="http://my.csdn.net/uploads/201205/11/1336732187_4598.jpg" alt="策略模式的结构"></p>
<p>**</p>
<h1 id="策略模式的组成："><a href="#策略模式的组成：" class="headerlink" title="策略模式的组成："></a><strong>策略模式的组成：</strong></h1><p><strong>环境类(Context)</strong>:用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。<br><strong>抽象策略类(Strategy)</strong>:定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。<br><strong>具体策略类(ConcreteStrategy)</strong>:以Strategy接口实现某具体算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Head-First设计模式学习笔记&quot;&gt;&lt;a href=&quot;#Head-First设计模式学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Head First设计模式学习笔记&quot;&gt;&lt;/a&gt;Head First设计模式学习笔记&lt;/h1&gt;&lt;p&gt;标签（空格分
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/05/21/hello-world/"/>
    <id>http://yoursite.com/2017/05/21/hello-world/</id>
    <published>2017-05-21T05:20:31.987Z</published>
    <updated>2017-05-21T05:20:31.996Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/05/21/README/"/>
    <id>http://yoursite.com/2017/05/21/README/</id>
    <published>2017-05-21T04:55:08.081Z</published>
    <updated>2017-05-21T05:04:18.947Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to the catyee’s Tech blog!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to the catyee’s Tech blog!&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
